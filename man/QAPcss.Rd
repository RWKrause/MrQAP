% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/QAPcss.R
\name{QAPcss}
\alias{QAPcss}
\title{Parameter and p-value estimation with MRQAP for CSS data}
\usage{
QAPcss(
  y,
  x,
  mode = "directed",
  diag = FALSE,
  nullhyp = "qapy",
  reps = 1000,
  seed = NULL,
  ncores = NULL,
  family = "gaussian",
  groups = NULL,
  reference = NULL,
  comparison = NULL,
  use_robust_errors = FALSE,
  random_intercept_group = FALSE,
  random_intercept_sender = FALSE,
  random_intercept_receiver = FALSE,
  random_intercept_perceiver = FALSE,
  random_intercept_other = NULL,
  error_file = NULL
)
}
\arguments{
\item{y}{array or list; \code{y} needs to be a cubic \code{array}. Alternatively, \code{y} can be a \code{list} of \code{array}s, if there are multiple CSS' that should be predicted at the same time.}

\item{x}{array or list; needs to be a cubic \code{array} with the same dimensions as \code{y} and is the predictor for \code{y}. In most cases you have more than one predictor. Then \code{x} needs to be a \code{list} of \code{array}s of the same dimensionality as \code{y}. If \code{y} is a \code{list}, then \code{x} should be a \code{list} of \code{list}s. Each predictor variable should be its own \code{list}, with each entrance being an \code{array} for each of the separate \code{array}s in \code{y}. These \code{list}s are then combined into one \code{list} of \code{list}s (e.g., \code{x[[1]][[2]]} is the predictor \code{array} of the first predictor(\code{[[1]]}) for the second group (\code{[[2]]})). It is highly recommended that \code{x} is named. The names will be carried to the output.}

\item{mode}{character; indicates whether the \code{array} in \code{y} is 'directed' or 'undirected'. If it is 'undirected' only the upper triangle (\code{upper.tri()}) of each perceiver \code{matrix} will be used.}

\item{diag}{logical; If \code{TRUE} diagonal values in each perceiver slice will also be included in the calculation. This is set to be \code{FALSE} by default and can potentially bias results when \code{TRUE}. (If \code{TRUE} is meaningful, it is recommended to run the model with and without \code{diag = TRUE} to see how relevant the diagonal is.)}

\item{nullhyp}{character; Currently only two baseline models are available \code{nullhyp = 'qapy'} and \code{nullhyp = 'qapspp'}. In general, 'qapspp' is the recommended option (see Dekker, Krackhardt, & Snijders, 2007). However, it costs more time and if all \code{x} are uncorrelated with each other both 'qapy' and 'qapspp' will give the same results.}

\item{reps}{integer; indicates how many permutations should be performed. Default is 1000 but larger numbers are highly recommended.}

\item{seed}{integer; Given the random nature of the permutation, every call of \code{QAPglm()} will lead to different responses that will asymptotically converge with larger values for \code{reps}. To get consistent answers, one should specify a random number seed with the seed argument (e.g., \code{seed = 1402}).}

\item{ncores}{integer; QAPcss() is parallelized (using the \code{parallel} package). If multiple cores are available, using them cuts the estimation in near linear relation by using multiple cores (e.g., \code{ncores = 10}). Be aware that depending on the \code{R} installation, parallelization can fail when too many cores are addressed at the same time. If you are using an HPC cluster, the recommendation is to submit many jobs, each only asking for 5-20 cores, and running only a few hundred \code{reps}. The resulting outputs can then be combined with the auxiliary function \code{combine_qap_estimates()}.}

\item{family}{character; While there is controversy around using anything but a linear model in MRQAP (family = 'gaussian'), \code{QAPglm()} supports all natural \code{R} model families (see \code{?family}). Use \code{family = 'multinom'} if a multinomial choice model is requested. Internally, estimation will be done with \code{multinom()} from the \code{nnet} package.}

\item{groups}{vector; It might be that a CSS is composed of qualitatively different groups. In that case, it might be desirable to only permute within groups. \code{groups} is a \code{vector} of \code{length = nrow(y)}, indicating the grouping of the nodes. (\code{groups} together with a \code{list} of \code{y} is not yet implemented but will be added soon.)}

\item{reference}{numeric or character; If \code{family = 'multinom'}, \code{reference} can be used to specify the reference group for the multinomial regression.}

\item{comparison}{list; In case accuracy of perception is the outcome three different methods are supported. First, one can run a multinomial choice model comparing true positives (TP), false positives (FP), false negatives (FN), and true negatives (TN) - it is recommended to use TN as \code{reference}, because it is the most likely result in many graphs. The problem with this approach is that the comparisons TN vs TP and TN vs FN are not reasonably applicable, the alternative to a true negative is not at true positive, but if i and j have no relationship (Y_{ij} = 0) then there can only be a true negative (Y_{ijk} = 0) or a false positive (Y_{ijk} = 1). The same applies when Y_{ij} = 1, then only true positives and false negatives are meaningful comparisons. Thus, the second option is to run \code{QAPcss()} twice, once with only TN and FP, setting all TP and FN to \code{NA} in \code{y} and \code{x} (and another time with the reverse set to \code{NA}). If the corresponding values in \code{x} are not set to \code{NA} the result should be asymptotically the same as option three. The third option is to specify the \code{comparison}. Provide a (named) \code{list} of the two or more comparisons to be performed: \code{qapCSS(...,       comparison = list(comission = c('false_positive', 'true_negative'), omission  = c('false_negative', 'true_positive')))}. The difference to option two is that here permutations of the entire cube are performed before it is split into the two comparisons and the requested analyses (see \code{family}) are performed. The data are internally re-coded to 0 and 1, thus linear probability models (\code{family = 'gaussian'}) and logistic regression (\code{family = 'binomial'}) are possible. This means that a value in \code{x} that was linked to a the TN vs FP comparison can also predict values in the FN vs TP comparison. More research is necessary to identify when which method gives the most reliable results.}

\item{use_robust_errors}{logical; indicates if internal standard errors should be adjusted for heteroskedasticity using the HC3 adjustment. This is by default \code{FALSE} but recommended when linear probability models are being used or heterogeneity is otherwise suspected. Results will overall be more conservative and thus significant findings more reliable.}

\item{error_file}{character; Not meant for the end-user. Passed to \code{makeCluster(ncores, outfile = error_file)}. See \code{?parallel::makeCluster}. Helpful if you want to debug the code.}

\item{random_intercept_...}{logical; Multiple arguments exist to specify random intercepts. instead of relying on \code{glm()} estimation will use the \code{lmer()} or \code{glmer()} from the \code{lme4} package to obtain parameter estimates and t-values for the permutation assessment. \code{random_intercept_group} includes a random intercept for each group in groups. \code{random_intercept_sender}, \code{random_intercept_receiver}, and \code{random_intercept_perceiver} add intercepts for each node on the corresponding dimension. Additionally, there is \code{random_intercept_other}. This argument expects an input corresponding to every element in \code{y} (either a similarly sized \code{matrix} or a \code{list} of \code{array}s corresponding to each element in \code{y} when \code{y} is a \code{list}). This \code{array} (or \code{list} thereof) will be used to create cell-specifc random intercepts. This might be useful if some relationships are qualitatively different than others but all are expected to follow the same pattern (e.g., for some cells differences in (intercept and) residual variance are expected). You can submit \code{list}s of \code{list}s of matrices if you want multiple random intercept variables added}
}
\value{
an object of \code{class} \code{QAPRegression} when \code{family = 'gaussian'} or \code{QAPGLM} otherwise. It contains the basic input parameters and estimated parameters and p-values.
import parallel
import lme4
}
\description{
This function allows you to estimate \code{lm()}, \code{glm()}, \code{lmer()}, \code{glmer()}, and m\code{ultinom()} models on cubic CSS data. Data structure is expected to be \code{y[i,j,k]} with i = sender, j = receiver, and k = perceiver. If your data is differently structured, be careful when using the \code{random_intercept_...} arguments.
}
\details{
Permutations are performed for all three dimensions simultaneously. If permutations should only be within perceiver slices, use \code{QAPglm()} instead.
}
